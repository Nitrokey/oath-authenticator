# Fuzzing

For the best robustness and to minimalize the panic-level issues, a fuzzing operation is in order. Here we use `cargo-fuzz` tool, which allows for a quick setup of the LLVM fuzzer. The entry point is in the [fuzz_target_1.rs](fuzz_target_1.rs) file.

## Corpus

Corpus can be generated by saving each output of the outgoing call to a file, while executing tests provided 
in pynitrokey for the oath-authenticator API. After doing so, all files should be placed in `corpus` directory. 
Optionally it can be minimized before the actual run.

### Quick Start

Corpus is pre-generated and attached to repository for a quick start and potential CI use. The archive name is `corpus.tar.gz`, and should be unpacked automatically in case there no corpus directory created yet. For the latter case please generate it as below.

### Generation

To generate corpus please use the latest pynitrokey source, and execute the tests for OTP Application with the `NK_FUZZ=1` 
environment variable set. To run the tests a NK3 device is needed - either a USB/IP simulation or a real hardware. 
Do not use production device, as the test cases written there contain destructive operations, including factory reset.

```shell
# One time operation
git clone https://github.com/Nitrokey/pynitrokey.git
make init
# Actual corpus generation
env NK_FUZZ=1 NK_FUZZ_PATH=/tmp/corpus ./venv/bin/pytest pynitrokey/test_otp.py
```

With the lines above executed, the resulted corpus is saved to `/tmp/corpus` path. Copy it back to this directory, 
so it can be used as a starting point for the fuzzing.

Current record format for the corpus data resembles the TLV structure, without the tag encoding - specifically:

| Field | Size   | Description                                                                |
|-------|--------|:---------------------------------------------------------------------------|
| Size  | 1 Byte | Size of the Data field                                                     |
| Data  | Size   | The request to the OTP App, as it would have been sent over CCID transport |


One request is one record. There is no records limit - the received corpus is read until the end, and upon parsing error (e.g. size bigger than the remaining data) the data collected until now are returned.


## Setup
Following call will required components for executing fuzzing process, and interpreting it later with the coverage statistics.

```shell
make setup
```


On some OSes, e.g. Fedora 37, it might be needed to link versioned `libclang` library to main name like so:

```shell
cd /usr/lib && sudo ln -s libclang.so.15 libclang.so
```

Please make sure this does not break your OS first. Perhaps a better solution is to use `LD_PRELOAD` here instead, with a local link.



## Run
To simply run the fuzzing operation with the default time and parallel jobs count execute:
```shell
make fuzz
```
Mentioned can be parametrized as in the following:
```shell
make fuzz FUZZ_DURATION=6000 FUZZ_JOBS=10
```


## Coverage

After finished fuzzing process it is possible to execute all the corpus files to see the code coverage with:
```shell
make fuzz-cov
```

This results in a fairly big HTML file called `fuzz_coverage.html`. It can be opened in browser, but for a quick look the fastest are TUI applications, like `links`. It contains all of the crates code used in the binary, and the oath-authenticator code is usually at the end of the file.